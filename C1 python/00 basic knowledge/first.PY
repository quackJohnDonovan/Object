import random




# 求1+2+3+....+100
# i = 1
# Sum = 0
#
# for i in range (1,101):
#
#     Sum = Sum + i
#     i = i + 1
#
# print(Sum)


'''
for i in range (1,101):
    print('hi')

for i in range(5,1,-1):
    print('i=',i)

for i in range(1,5):
    for j in range(1, i+1):
        print('i=',i,"j=",j)





while(i < 101):
    Sum = Sum + i
    i = i + 1
print(Sum)
所以，for循环既不用配置变量i，也不用写i = i + 1
用while的时候，两者都要写
'''
#九九乘法表

for i in range(1,10):
    for j in range(1,i+1):
        if j < i:
            print(j, 'x', i, '=', i * j,'\t', end='  ')
        else:
            print(j, 'x', i, '=', i * j)

'''
#九九乘法表

for i in range(1,10):
    for j in range(1,i+1):
        if j < i:
            print(j, 'x', i, '=', i * j,'\t', end='  ')
        else:
            print(j, 'x', i, '=', i * j)
1、看到乘法表中第一个乘数每行累加，第二个乘数每行不变，已知不变的数我们放在外层循环，如上面的参数i，
   所以累加的乘数j我们放在内循环
2、i的范围：看乘法表中i的最大值为9，最小值为1，已知range里面最大值要加1，则可以写出for i in range(1,10)
   j的范围：可以看到第一行到1，第二行到2，所以第i行到i，已知range里面最大值要加1，则可以写出for i in range(1,i+1)
3、换行：看乘法表可发现j小于i时不换行，等于i时换行，所以用if做判断，可见上面的if写法
4、对齐(\t为制表符、也可以代替)：做完第三步后会发现，结果为两位数时，后面的算式会被推后一格，导致字体排版不一致，
        所以可在if中使用嵌套if，使结果为两位数时，end参数少打印一个空格，结果为1位数时，比两位数多打印一个空格
        这样就得到了一个完美的乘法表
'''


'''
#input

input函数输入的内容会被强制转换为string类型

choice = input('你的选择是1还是2\n')
print(type(choice))

上述代码运行后结果为<class 'str'>

那么，我可以让判断条件等于一个字符串就行

choice = input('请输入您的选择：')
#变量赋值

if choice == '1':
#条件判断:条件1
    print('霍格沃茨欢迎您的到来。')
#条件1的结果

else:
#条件判断：其他条件
    print('您可是被梅林选中的孩子，我们不接受这个选项。')
#其他条件的结果

'''


'''
#冒泡排序前置知识点-列表

列表样式：
students = ['小明','小红','小刚']
里面的每一个数据叫做’元素‘

列表循环：
list1=['小明','18','1.70']
for q in list1:
	print(q)
这样就会把list1中每一项元素一个个列出来，注意是’一个个列出来‘

从列表中提取单个元素：
students = ['小明','小红','小刚']
print(students[0])
注意，从0开始哦。上面运行后把’小明‘提取出来了

从列表中提取多个元素：
    list2 = [5,6,7,8,9]
    print(list2[:])
意味着提取所有元素
    print(list2[2:])
意味着提取第2、3、4位元素，即7、8、9
    print(list2[:2])
意味着提取第0、1位元素，即5、6（与for循环的range异曲同工）
    print(list2[1:3])
6、7
    print(list2[2:4])
7、8
总结:
冒号左边空，就要从偏移量为0的元素开始取；右边空，就要取到列表的最后一个元素。后半句：冒号左边数字对应的元素要拿，右边的不动
    list2 = [5,6,7,8,9]
    print(list2[0])
    print(list2[:1])
差别：前者取到的是元素，后者取到的还是列表
这俩结果一致，都是取出5，不过一个是5，一个是[5]

增加列表元素:
    list3 = [1,2]
    list3.append(3)
    print(list3)
对于列表来说，append方法一次只能增加一个元素，比如list3.append(3，4)就不行
    list3.append([4,5])
    print(list3)
用中括号把4，5当成一个元素就可以了
这样结果就是[1,2,3,[4,5]]

删除列表元素：
    students = ['小明','小红','小刚','小美']
    del students[1]
    print(students)
也可以一次删除多个
    del students[:]

列表嵌套:
    students = [['小明','小红','小刚','小美'],['小强','小兰','小伟','小芳']]
    print(students[1][1])
结果为小兰

'''


'''
#冒泡排序前置知识点-字典

对比：
    students = ['小明','小红','小刚']
    scores = {'小明':95,'小红':90,'小刚':90}
1、字典和列表有3个地方是一样的：1.有名称；2.要用=赋值；3.用逗号作为元素间的分隔符
   不一样的有两处：1.列表外层用的是中括号[ ]，字典的外层是大括号{ }；
2、列表中的元素是自成一体的，而字典的元素是由一个个键值对构成的，用英文冒号连接。如'小明':95，其中我们把'小明'叫键（key），95叫值(value)。
   上述字典就有3个【键值对】：'小明':95、'小红':90、'小刚':90
3、列表顺序不同就是两个不同的列表，字典顺序不同没关系
   这也是为什么两者数据读取方法会不同的原因：列表有序，要用偏移量定位；字典无序，便通过唯一的键来取值。

查看长度：
    students = ['小明','小红','小刚']
    scores = {'小明':95,'小红':90,'小刚':90}
    print(len(students))
    print(len(scores))
两个答案都是3
字典中的键具备唯一性，而值可重复。也就是说字典里不能同时包含两个'小明'的键，但却可以有两个同为90的值。

字典中取出值：
    scores = {'小明': 95, '小红': 90, '小刚': 90}
    print(scores['小明'])
结果为95

增加键值对:
    scores = {}
    scores['小明']=92
    scores['小美']=85
    print(scores)
没有的时候添加，有的时候修改
    
删除键值对：
    album = {'周杰伦':'七里香','王力宏':'心中的日月'}
    del album['周杰伦']
    print(album)
    
字典嵌套字典：
scores = {
    '第一组':{'小明':95,'小红':90,'小刚':100,'小美':85},
    '第二组':{'小强':99,'小兰':89,'小伟':93,'小芳':88}
    }
print(scores['第一组']['小刚'])

相互嵌套：
# 1、最外层是大括号，所以是字典嵌套列表，先找到字典的键对应的列表，再判断列表中要取出元素的偏移量
students = {
    '第一组':['小明','小红','小刚','小美'],
    '第二组':['小强','小兰','小伟','小芳']
    }
print(students['第一组'][3])
# 取出'第一组'对应列表偏移量为3的元素，即'小美'
# 2、最外层是中括号，所以是列表嵌套字典，先判断字典是列表的第几个元素，再找出要取出的值相对应的键
scores = [
    {'小明':95,'小红':90,'小刚':100,'小美':85},
    {'小强':99,'小兰':89,'小伟':93,'小芳':88}
    ]
print(scores[1]['小强'])
#先定位到列表偏移量为1的元素，即第二个字典，再取出字典里键为'小强'对应的值，即99。


扩展：元组
tuple1 = ('A','B')
list2 = [('A','B'),('C','D'),('E','F')]

print(tuple1[0])
print(list2[1][1])

# 从代码里，也可看出：1.元组内数据的提取也是用偏移量；2.元组也支持互相嵌套。
'''


'''
#冒泡排序

list = [8,2,6,3,9,7,1,5,4]

k = 0
for i in range(0,len(list)-1):
    for j in range(0,len(list)-1):
        if list[j] > list[j+1]:
            k = list[j]
            list[j] = list[j+1]
            list[j+1] = k

print(list)

'''








